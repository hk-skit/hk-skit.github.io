<div class="content">
  <div class="wrap">
    <div class="single-page">
      <div class="single-page-artical">
        <div class="artical-content">
          <!--<img src="images/single-post-pic.jpg" title="Dilemma of this keyword">-->
          <h2><a>Dilemma of <code> this</code> keyword</a></h2>
          <p>
            <code>this</code> keyword of javascript almost haunts every programmer whether he is novice or experienced.
            <code>this</code> changes it's behaviour like a girl changes her clothes :). When you'll dive into this
            post you'll know why I said so. Why <code>this</code> act like a weirdo, but once you understand it's eccentric 
            behaviour you will find that it is very easy to comprehend and use. Before we proceed further, one thing I want to make 
            clear is that I am not teaching or explaining about <code>this</code> here. I am just sharing what I have learned
            so far. I am in leanring phase. So if you find something which is not articualted or something which I have 
            misinterpreted, please feel free to reach out to me or post your comment in comment sections. I will make amendments happly.
            Almost two years ago, when I started learning JavaScript, <code>this</code> confused me a lot but after satying 
            with it for longer run, I finally acquianted myself with it. In this post I am writing whatever I have learned and observed
            reagrding to <code>this</code>. This is my very first techincal post. I hope it will be helpful. So let's start.
          </p>
          <quote>****It's not that I'm so smart, it's just that I stay with problem for longer ~ Albert Einstein****</quote>
          
          <p>
            Javascript's <code>this</code> is completely different from other Object Oriented Languages. In Object Oriented Languages 
            like Java, C# <code>this</code> refers to the current instance of the class. While in JavaScript, <code>this</code> refers
            to the context of invocation and where it is called. The value of <code>this</code> is determined by invocation pattern. As 
            <a href="www.crockford.com" target="blank">Douglous Crockford</a> explained in JavaScript: The Good Part, There are four
            patterns of invocation:
            <ol>
              <li> Method Invocation Pattern: Function is called using an object reference.</li>
              <li> Function Invocation Pattern: Simple JavaScript function call.</li>
              <li> Constructor Invocation Pattern: Function is called with <code>new</code>.</li>
              <li> Apply Invocation Pattern: Function is called using <code>call</code>,<code>apply</code> & <code>bind</code>.</li>
            </ol><br>
            So behaviour or value of <code>this</code> for a <code>function</code> depends on the context in which it is invoked i.e. 
            it's invocation pattern. We will discuss invocation patterns briefly along with <code>this</code> to undertsand it fully. 
            An invocation pattern is a way of calling a <code>function</code>. In JavaScript there are four ways by means of which a 
            function can be invoked. Value of <code>this</code> mainly depends on these invocation patterns.
            <p>a) With Function Invocation Pattern(Global Context or Context-free):</p>
          When a function is not a property of an object then it is invoked as a function:</p>
          <div hljs>
            //function invocation pattern
            var tweets = loadTweets();
          </div>
          <p>Look at the examples below and guess what will we console log.</p>
            <h3>Ex1:</h3><br>
            <div hljs>
              //function invocation pattern
              function helloThis() {  
                console.log(this);
              }
              helloThis();
            </div><br>
            <h3>Ex2:</h3><br>
            <div hljs>
              //function invocation pattern, IIFE
              (function() {
                 console.log(this);
              }());
            </div><br>
            <h3>Ex3:</h3><br>
            <div hljs>
                //function invocation pattern, IIFE
                (function() {
                   function helloThis() {
                     console.log(this);
                  }
                  helloThis();
                }());
            </div>
            <p>
          You will be surprised to know that in Ex1, Ex2 and Ex3 all log the same value i.e. <code>window</code> object. In all three cases value of
          <code>this</code> is bound to global object. Whenever a function is invoked using function invocation pattern(function is 
          called directly without any context e.g. <code>add(3,4)</code>), so it's <code>this</code> is bound to global object i.e. 
          <code>window</code> object.<br> 
          NOTE: If you have <code>'use strict';</code> statement in your script or on top of your function then in global context
          (function is invoked using Function Invocation Pattern inside an annonymous function or directly in script.) value
          of <code>this</code> is <code>undefined</code>. Let's try a couple of more example:    
            </p>
          <h3>Ex4:</h3><br>
          <div hljs>
            function Person() {
                function x() {
                  console.log(this);
                }
                x();
            }
            var p = new Person();
          </div><br>
          <h3>Ex5:</h3><br>
          <div hljs>
            var x = {
                      a: 131,
                      b: function() {
                            function x(){
                               console.log(this);
                            }
                            x();
                          }
                    };
             x.b();
             </div><br>
             <h3>Ex6:</h3><br>
             <div hljs>
             var button=document.getElementById('myClick');
             button.addEventListener('click',function(e){
             function x(){
            console.log(this);
             } x();
             });
          </div>
          <p>So far by looking at these examples one thing is clear that whenever a function is invoked using function invocation pattern
          it's <code>this</code> refers to global object i.e. <code>window</code> object of browser(if <code>'use strict';</code> is used
          then <code>this</code> is <code>undefined</code>).</p>
          <p>b) Method invocation pattern(object-context):</p>
          <p>When a function is stored as a property of an object, it is called method. Whenever a method is called it's <code>this</code>
          is bound to it's object by which it is called. Eg.</p>
          <h3>Ex7:</h3><br>
            <div hljs>
               var x={ 
                   a: 12,
                   b: function (){ 
                       console.log(this);
                      }
               };
               x.b();
            </div>
          <p>Output: It logs <code>this</code> of object <code>x</code> i.e. <code>x</code> itself. Once we understand context part 
          of <code>this</code> keyword then it becomes very easy to use it. The <code>this</code> keyword of a function is always to 
          bound to the context by which it is called. If there's no context(function invocation) then <code>this</code> is bound to
          global object. Whenever I get confused with this keyword I always recall this line and the confusion is cleared. It's worth 
          repeating: <quote>****<code>this</code> keyword of a function is always bound to the context by which it is called.****</quote>
          If there's no context then 'this' is bound to global object. You can try it with any example. You will find that whatever I 
          said always makes sense regardless of the situation you are in. Let's have some example which proves that whatever I said is
          true:</p>
          <h3>Ex8</h3><br>
          <div hljs>
            var x={
                a: 12,
                b: function (){
                      //refers the object using which b is called.
                      //Here is called using x so this refers to x.
                      console.log(this); 
                      function helloThis(){
                        //helloThis is called without any context.
                        //So this is bound to global context.
                        console.log(this);
                      } 
                      helloThis();
                    }
            };
            x.b();
          </div>
          <p>Output: First log statment logs <code>x</code> and second logs <cdoe>window</cdoe> object.</p>
          <h3>Ex9:</h3><br>
          <div hljs>
            var x={
                    a: 12,
                    b: function (){ 
                        //refers the object using which b is called.
                        //Here is called using x so this refers to x.
                        console.log(this);
                        function helloThis(){
                          //helloThis is called without any context.
                          //So this is bound to global context.
                          console.log(this);
                        }
                        helloThis();
                        },
                    c: {
                         d: 12313,
                         e: function(){
                              console.log(this);
                              function sayThis(){
                                console.log(this);
                              } 
                              sayThis();
                            }
                        }
                  };
                  x.c.e();
          </div>
          <p>Output: First log inside <code>e</code> logs object <code>c</code> and second log logs <code>window</code> object. So we can 
          see that it does not matter how much nested it becomes <code>this</code> keyword of a <code>function</code> is always bound to
          the context by which it is called. If there's no context then <code>this</code> is bound to global object. I will repeat this
          statement till the end of post cause it solves the dilemma of <code>this</code> :).</p>
          <p>
            c) Constructor invocation pattern:
          </p>
          <p>
            As written in JavaScript good parts, Functions which are intended to be used with <code>new</code> prefix are called 
            constructors. In javascript, we can call a function using <code>new</code> to create objects. In this case 
            <code>function</code> plays the role of constructor. eg. <code>var p = new Person();</code> Here <code>Person</code>
            is invoked as constructor which creates an object <code>p</code> of type/instance <code>Person</code>. You might be 
            thinking why we are discussing constructors here. To understand <code>this</code> it is important to be familiar with
            constructor in JavaScript. If you are not familiar with constructor then don't worry I'll explain it briefly. In
            JavaScript, constructor are simliar to function but they are meant to create object. They are invoked with the 
            <code>new</code> keyword. e.g.
          </p>
          <h3>Ex:10</h3><br>
          <div hljs>
            function Singer(firstName,lastName){ 
                this.firstName = firstName;
                this.lastName = lastName;
                this.toString = function(){
                  return this.firstName + ' ' + this.lastName;
                };
            }
            var bruno = new Singer('Bruno', 'Mars');
            console.log(bruno.toString());//Bruno Mars.
          </div>
          <p>
            Whenever a function is invoked with <code>new</code> keyword, a new object is created with a hidden link to the function's
            prototype member and <code>this</code> is bound to the <code>new</code> object. Here when we called <code>Singer</code> 
            function using <code>new</code> a <code>bruno</code> object is created with the hidden link of prototype of <code>Singer</code>
            and it's this is bound to bruno object.
          </p>
          <h3>Ex:11</h3><br>
          <div hljs>
            function Singer(firstName,lastName) {
                this.firstName = firstName;
                this.lastName = lastName;
                this.toString = function() { 
                    console.log(this);
                    function sayThis(){
                        console.log(this);
                    }
                    sayThis();
                return this.firstName+' '+this.lastName;
                };
           }
           var bruno = new Singer('Bruno', 'Mars');
           bruno.toString();
          </div>
           <p>
             First log logs <code>bruno</code> object and second log logs <code>window</code> object. So now again you can see that 
             <code>this</code> keyword of a function is always bound to the context by which it is called. Now we'll see how 
             <code>this</code> behaves when it is in <code>event</code>callback.
        </div>
      </div>
    </div>
  </div>
</div>